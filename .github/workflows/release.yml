# Semantic Release Workflow
#
# Automatically creates releases based on conventional commits
# - feat: minor version bump
# - fix: patch version bump
# - feat!: or BREAKING CHANGE: major version bump

name: Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.github/workflows/**'
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  id-token: write

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install semantic-release
        run: npm install -g semantic-release @semantic-release/git @semantic-release/changelog @semantic-release/exec

      - name: Create semantic-release config
        run: |
          cat > .releaserc.json << 'RELEASERC'
          {
            "branches": ["main"],
            "plugins": [
              "@semantic-release/commit-analyzer",
              "@semantic-release/release-notes-generator",
              ["@semantic-release/changelog", {
                "changelogFile": "CHANGELOG.md"
              }],
              ["@semantic-release/git", {
                "assets": ["CHANGELOG.md"],
                "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
              }],
              "@semantic-release/github"
            ]
          }
          RELEASERC

      - name: Run semantic-release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(npx semantic-release 2>&1) || true
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "Published release"; then
            VERSION=$(echo "$OUTPUT" | grep -oP 'Published release \K[0-9]+\.[0-9]+\.[0-9]+')
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
          else
            echo "new_release_published=false" >> $GITHUB_OUTPUT
          fi

  build-binaries:
    needs: release
    if: needs.release.outputs.new_release_published == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: lib/go.mod
          cache-dependency-path: |
            lib/go.sum
            cmd/go.sum

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          cd cmd
          go build -ldflags="-s -w -X main.Version=${{ needs.release.outputs.new_release_version }}" -o ptd .

          # Create archive
          ARCHIVE_NAME="ptd_${{ needs.release.outputs.new_release_version }}_${{ matrix.goos }}_${{ matrix.goarch }}.tar.gz"
          tar -czvf "../$ARCHIVE_NAME" ptd
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV

      - name: Upload to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "v${{ needs.release.outputs.new_release_version }}" "${{ env.ARCHIVE_NAME }}" --clobber

  update-checksums:
    needs: [release, build-binaries]
    runs-on: ubuntu-latest
    steps:
      - name: Download all release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download "v${{ needs.release.outputs.new_release_version }}" --repo ${{ github.repository }} --dir ./assets

      - name: Generate checksums
        run: |
          cd assets
          sha256sum *.tar.gz > checksums.txt
          cat checksums.txt

      - name: Upload checksums
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "v${{ needs.release.outputs.new_release_version }}" ./assets/checksums.txt --clobber --repo ${{ github.repository }}
